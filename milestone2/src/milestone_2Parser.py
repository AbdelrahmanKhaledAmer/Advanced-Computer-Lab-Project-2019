# Generated from /home/mark/Dev/Semester10/CompilersLab/Project/milestone2/src/milestone_2.g4 by ANTLR 4.6
# encoding: utf-8
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3\u0090")
        buf.write("{\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\3\2\3\2\3\2\3\2\7\2\33")
        buf.write("\n\2\f\2\16\2\36\13\2\3\2\3\2\3\2\3\2\3\2\3\2\7\2&\n\2")
        buf.write("\f\2\16\2)\13\2\5\2+\n\2\3\3\3\3\5\3/\n\3\3\3\6\3\62\n")
        buf.write("\3\r\3\16\3\63\3\4\3\4\3\4\3\4\5\4:\n\4\3\4\5\4=\n\4\3")
        buf.write("\5\3\5\3\6\6\6B\n\6\r\6\16\6C\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6S\n\6\3\7\3\7\5\7W\n\7")
        buf.write("\3\7\6\7Z\n\7\r\7\16\7[\3\b\3\b\3\b\7\ba\n\b\f\b\16\b")
        buf.write("d\13\b\3\b\3\b\3\b\5\bi\n\b\3\b\5\bl\n\b\3\t\3\t\3\n\3")
        buf.write("\n\3\n\5\ns\n\n\3\13\7\13v\n\13\f\13\16\13y\13\13\3\13")
        buf.write("\2\2\f\2\4\6\b\n\f\16\20\22\24\2\4\5\2\33\33\66\66OO\3")
        buf.write("\2\3\21\u008d\2*\3\2\2\2\4,\3\2\2\2\6<\3\2\2\2\b>\3\2")
        buf.write("\2\2\nR\3\2\2\2\fT\3\2\2\2\16k\3\2\2\2\20m\3\2\2\2\22")
        buf.write("r\3\2\2\2\24w\3\2\2\2\26\27\7/\2\2\27\34\7T\2\2\30\31")
        buf.write("\7\u0084\2\2\31\33\7T\2\2\32\30\3\2\2\2\33\36\3\2\2\2")
        buf.write("\34\32\3\2\2\2\34\35\3\2\2\2\35+\3\2\2\2\36\34\3\2\2\2")
        buf.write("\37 \7,\2\2 !\7T\2\2!\"\7/\2\2\"\'\7T\2\2#$\7\u0084\2")
        buf.write("\2$&\7T\2\2%#\3\2\2\2&)\3\2\2\2\'%\3\2\2\2\'(\3\2\2\2")
        buf.write("(+\3\2\2\2)\'\3\2\2\2*\26\3\2\2\2*\37\3\2\2\2+\3\3\2\2")
        buf.write("\2,\61\5\b\5\2-/\7\u008e\2\2.-\3\2\2\2./\3\2\2\2/\60\3")
        buf.write("\2\2\2\60\62\5\6\4\2\61.\3\2\2\2\62\63\3\2\2\2\63\61\3")
        buf.write("\2\2\2\63\64\3\2\2\2\64\5\3\2\2\2\65\66\7T\2\2\66\67\7")
        buf.write("n\2\2\679\5\n\6\28:\7\u008c\2\298\3\2\2\29:\3\2\2\2:=")
        buf.write("\3\2\2\2;=\7\u008c\2\2<\65\3\2\2\2<;\3\2\2\2=\7\3\2\2")
        buf.write("\2>?\t\2\2\2?\t\3\2\2\2@B\7V\2\2A@\3\2\2\2BC\3\2\2\2C")
        buf.write("A\3\2\2\2CD\3\2\2\2DS\3\2\2\2ES\7W\2\2FS\7X\2\2GS\7Y\2")
        buf.write("\2HS\7Z\2\2IS\7[\2\2JS\7\\\2\2KS\7]\2\2LS\7^\2\2MS\7_")
        buf.write("\2\2NS\7d\2\2OS\7`\2\2PS\7b\2\2QS\7\u0086\2\2RA\3\2\2")
        buf.write("\2RE\3\2\2\2RF\3\2\2\2RG\3\2\2\2RH\3\2\2\2RI\3\2\2\2R")
        buf.write("J\3\2\2\2RK\3\2\2\2RL\3\2\2\2RM\3\2\2\2RN\3\2\2\2RO\3")
        buf.write("\2\2\2RP\3\2\2\2RQ\3\2\2\2S\13\3\2\2\2TY\5\b\5\2UW\7\u008e")
        buf.write("\2\2VU\3\2\2\2VW\3\2\2\2WX\3\2\2\2XZ\5\16\b\2YV\3\2\2")
        buf.write("\2Z[\3\2\2\2[Y\3\2\2\2[\\\3\2\2\2\\\r\3\2\2\2]b\7T\2\2")
        buf.write("^_\7\u0084\2\2_a\7T\2\2`^\3\2\2\2ad\3\2\2\2b`\3\2\2\2")
        buf.write("bc\3\2\2\2ce\3\2\2\2db\3\2\2\2ef\7}\2\2fh\5\20\t\2gi\7")
        buf.write("\u008c\2\2hg\3\2\2\2hi\3\2\2\2il\3\2\2\2jl\7\u008c\2\2")
        buf.write("k]\3\2\2\2kj\3\2\2\2l\17\3\2\2\2mn\t\3\2\2n\21\3\2\2\2")
        buf.write("os\5\4\3\2ps\5\2\2\2qs\5\f\7\2ro\3\2\2\2rp\3\2\2\2rq\3")
        buf.write("\2\2\2s\23\3\2\2\2tv\5\22\n\2ut\3\2\2\2vy\3\2\2\2wu\3")
        buf.write("\2\2\2wx\3\2\2\2x\25\3\2\2\2yw\3\2\2\2\22\34\'*.\639<")
        buf.write("CRV[bhkrw")
        return buf.getvalue()


class milestone_2Parser ( Parser ):

    grammarFileName = "milestone_2.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'int'", "'int8'", "'int16'", "'int32'", 
                     "'int64'", "'uint'", "'uint8'", "'uint16'", "'uint32'", 
                     "'uint64'", "'float'", "'float32'", "'float64'", "'char'", 
                     "'string'", "'and'", "'addr'", "'as'", "'asm'", "'bind'", 
                     "'block'", "'break'", "'case'", "'cast'", "'const'", 
                     "'concept'", "'continue'", "'converter'", "'defer'", 
                     "'discard'", "'distinct'", "'div'", "'do'", "'elif'", 
                     "'else'", "'end'", "'enum'", "'except'", "'export'", 
                     "'finally'", "'for'", "'from'", "'func'", "'if'", "'import'", 
                     "'in'", "'include'", "'interface'", "'is'", "'isnot'", 
                     "'iterator'", "'let'", "'macro'", "'method'", "'mixin'", 
                     "'mod'", "'nil'", "'not'", "'notin'", "'object'", "'of'", 
                     "'or'", "'out'", "'proc'", "'ptr'", "'raise'", "'ref'", 
                     "'return'", "'shl'", "'shr'", "'static'", "'template'", 
                     "'try'", "'tuple'", "'type'", "'using'", "'var'", "'when'", 
                     "'while'", "'xor'", "'yield'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'+'", "'*'", "'-'", "'/'", "'~'", "'&'", 
                     "<INVALID>", "'<'", "'>'", "'@'", "'!'", "'%'", "'^'", 
                     "'.'", "':'", "'('", "')'", "'{'", "'}'", "'['", "']'", 
                     "','", "';'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "AND", "ADDR", "AS", "ASM", "BIND", "BLOCK", "BREAK", 
                      "CASE", "CAST", "CONST", "CONCEPT", "CONTINUE", "CONVERTER", 
                      "DEFER", "DISCARD", "DISTINCT", "DIV", "DO", "ELIF", 
                      "ELSE", "END", "ENUM", "EXCEPT", "EXPORT", "FINALLY", 
                      "FOR", "FROM", "FUNC", "IF", "IMPORT", "IN", "INCLUDE", 
                      "INTERFACE", "IS", "ISNOT", "ITERATOR", "LET", "MACRO", 
                      "METHOD", "MIXIN", "MOD", "NIL", "NOT", "NOTIN", "OBJECT", 
                      "OF", "OR", "OUT", "PROC", "PTR", "RAISE", "REF", 
                      "RETURN", "SHL", "SHR", "STATIC", "TEMPLATE", "TRY", 
                      "TUPLE", "TYPE", "USING", "VARIABLE", "WHEN", "WHILE", 
                      "XOR", "YIELD", "IDENTIFIER", "LETTER", "DIGIT", "INT8_LIT", 
                      "INT16_LIT", "INT32_LIT", "INT64_LIT", "UINT_LIT", 
                      "UINT8_LIT", "UINT16_LIT", "UINT32_LIT", "UINT64_LIT", 
                      "FLOAT32_LIT", "FLOAT32_SUFFIX", "FLOAT64_LIT", "FLOAT64_SUFFIX", 
                      "FLOAT_LIT", "EXP", "INT_LIT", "HEX_LIT", "DEC_LIT", 
                      "OCT_LIT", "BIN_LIT", "HEXDIGIT", "OCTDIGIT", "BINDIGIT", 
                      "EQUALS_OPERATOR", "ADD_OPERATOR", "MUL_OPERATOR", 
                      "MINUS_OPERATOR", "DIV_OPERATOR", "BITWISE_NOT_OPERATOR", 
                      "AND_OPERATOR", "OR_OPERATOR", "LESS_THAN", "GREATER_THAN", 
                      "AT", "NOT_OPERATOR", "MODULUS", "XOR_OPERATOR", "DOT", 
                      "COLON", "OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACE", 
                      "CLOSE_BRACE", "OPEN_BRACK", "CLOSE_BRACK", "COMMA", 
                      "SEMI_COLON", "STR_LIT", "CHAR_LIT", "TRIPLESTR_LIT", 
                      "RSTR_LIT", "GENERALIZED_STR_LIT", "GENERALIZED_TRIPLESTR_LIT", 
                      "COMMENT", "MULTILINE_COMMENT", "INDENT", "WHITESPACE", 
                      "NEWLINE" ]

    RULE_importStmt = 0
    RULE_assignStmt = 1
    RULE_assignStmtBody = 2
    RULE_assignKeyw = 3
    RULE_assignDataTypes = 4
    RULE_declareStmt = 5
    RULE_declareStmtBody = 6
    RULE_declareDataTypes = 7
    RULE_stmts = 8
    RULE_start = 9

    ruleNames =  [ "importStmt", "assignStmt", "assignStmtBody", "assignKeyw", 
                   "assignDataTypes", "declareStmt", "declareStmtBody", 
                   "declareDataTypes", "stmts", "start" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    AND=16
    ADDR=17
    AS=18
    ASM=19
    BIND=20
    BLOCK=21
    BREAK=22
    CASE=23
    CAST=24
    CONST=25
    CONCEPT=26
    CONTINUE=27
    CONVERTER=28
    DEFER=29
    DISCARD=30
    DISTINCT=31
    DIV=32
    DO=33
    ELIF=34
    ELSE=35
    END=36
    ENUM=37
    EXCEPT=38
    EXPORT=39
    FINALLY=40
    FOR=41
    FROM=42
    FUNC=43
    IF=44
    IMPORT=45
    IN=46
    INCLUDE=47
    INTERFACE=48
    IS=49
    ISNOT=50
    ITERATOR=51
    LET=52
    MACRO=53
    METHOD=54
    MIXIN=55
    MOD=56
    NIL=57
    NOT=58
    NOTIN=59
    OBJECT=60
    OF=61
    OR=62
    OUT=63
    PROC=64
    PTR=65
    RAISE=66
    REF=67
    RETURN=68
    SHL=69
    SHR=70
    STATIC=71
    TEMPLATE=72
    TRY=73
    TUPLE=74
    TYPE=75
    USING=76
    VARIABLE=77
    WHEN=78
    WHILE=79
    XOR=80
    YIELD=81
    IDENTIFIER=82
    LETTER=83
    DIGIT=84
    INT8_LIT=85
    INT16_LIT=86
    INT32_LIT=87
    INT64_LIT=88
    UINT_LIT=89
    UINT8_LIT=90
    UINT16_LIT=91
    UINT32_LIT=92
    UINT64_LIT=93
    FLOAT32_LIT=94
    FLOAT32_SUFFIX=95
    FLOAT64_LIT=96
    FLOAT64_SUFFIX=97
    FLOAT_LIT=98
    EXP=99
    INT_LIT=100
    HEX_LIT=101
    DEC_LIT=102
    OCT_LIT=103
    BIN_LIT=104
    HEXDIGIT=105
    OCTDIGIT=106
    BINDIGIT=107
    EQUALS_OPERATOR=108
    ADD_OPERATOR=109
    MUL_OPERATOR=110
    MINUS_OPERATOR=111
    DIV_OPERATOR=112
    BITWISE_NOT_OPERATOR=113
    AND_OPERATOR=114
    OR_OPERATOR=115
    LESS_THAN=116
    GREATER_THAN=117
    AT=118
    NOT_OPERATOR=119
    MODULUS=120
    XOR_OPERATOR=121
    DOT=122
    COLON=123
    OPEN_PAREN=124
    CLOSE_PAREN=125
    OPEN_BRACE=126
    CLOSE_BRACE=127
    OPEN_BRACK=128
    CLOSE_BRACK=129
    COMMA=130
    SEMI_COLON=131
    STR_LIT=132
    CHAR_LIT=133
    TRIPLESTR_LIT=134
    RSTR_LIT=135
    GENERALIZED_STR_LIT=136
    GENERALIZED_TRIPLESTR_LIT=137
    COMMENT=138
    MULTILINE_COMMENT=139
    INDENT=140
    WHITESPACE=141
    NEWLINE=142

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.6")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ImportStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(milestone_2Parser.IMPORT, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.IDENTIFIER)
            else:
                return self.getToken(milestone_2Parser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.COMMA)
            else:
                return self.getToken(milestone_2Parser.COMMA, i)

        def FROM(self):
            return self.getToken(milestone_2Parser.FROM, 0)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_importStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportStmt" ):
                listener.enterImportStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportStmt" ):
                listener.exitImportStmt(self)




    def importStmt(self):

        localctx = milestone_2Parser.ImportStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_importStmt)
        self._la = 0 # Token type
        try:
            self.state = 40
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [milestone_2Parser.IMPORT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 20
                self.match(milestone_2Parser.IMPORT)
                self.state = 21
                self.match(milestone_2Parser.IDENTIFIER)
                self.state = 26
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==milestone_2Parser.COMMA:
                    self.state = 22
                    self.match(milestone_2Parser.COMMA)
                    self.state = 23
                    self.match(milestone_2Parser.IDENTIFIER)
                    self.state = 28
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [milestone_2Parser.FROM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 29
                self.match(milestone_2Parser.FROM)
                self.state = 30
                self.match(milestone_2Parser.IDENTIFIER)
                self.state = 31
                self.match(milestone_2Parser.IMPORT)
                self.state = 32
                self.match(milestone_2Parser.IDENTIFIER)
                self.state = 37
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==milestone_2Parser.COMMA:
                    self.state = 33
                    self.match(milestone_2Parser.COMMA)
                    self.state = 34
                    self.match(milestone_2Parser.IDENTIFIER)
                    self.state = 39
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignKeyw(self):
            return self.getTypedRuleContext(milestone_2Parser.AssignKeywContext,0)


        def assignStmtBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(milestone_2Parser.AssignStmtBodyContext)
            else:
                return self.getTypedRuleContext(milestone_2Parser.AssignStmtBodyContext,i)


        def INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.INDENT)
            else:
                return self.getToken(milestone_2Parser.INDENT, i)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_assignStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignStmt" ):
                listener.enterAssignStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignStmt" ):
                listener.exitAssignStmt(self)




    def assignStmt(self):

        localctx = milestone_2Parser.AssignStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_assignStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 42
            self.assignKeyw()
            self.state = 47 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 44
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==milestone_2Parser.INDENT:
                    self.state = 43
                    self.match(milestone_2Parser.INDENT)


                self.state = 46
                self.assignStmtBody()
                self.state = 49 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & ((1 << (milestone_2Parser.IDENTIFIER - 82)) | (1 << (milestone_2Parser.COMMENT - 82)) | (1 << (milestone_2Parser.INDENT - 82)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignStmtBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(milestone_2Parser.IDENTIFIER, 0)

        def EQUALS_OPERATOR(self):
            return self.getToken(milestone_2Parser.EQUALS_OPERATOR, 0)

        def assignDataTypes(self):
            return self.getTypedRuleContext(milestone_2Parser.AssignDataTypesContext,0)


        def COMMENT(self):
            return self.getToken(milestone_2Parser.COMMENT, 0)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_assignStmtBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignStmtBody" ):
                listener.enterAssignStmtBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignStmtBody" ):
                listener.exitAssignStmtBody(self)




    def assignStmtBody(self):

        localctx = milestone_2Parser.AssignStmtBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_assignStmtBody)
        try:
            self.state = 58
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [milestone_2Parser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 51
                self.match(milestone_2Parser.IDENTIFIER)
                self.state = 52
                self.match(milestone_2Parser.EQUALS_OPERATOR)
                self.state = 53
                self.assignDataTypes()
                self.state = 55
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 54
                    self.match(milestone_2Parser.COMMENT)


                pass
            elif token in [milestone_2Parser.COMMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 57
                self.match(milestone_2Parser.COMMENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignKeywContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VARIABLE(self):
            return self.getToken(milestone_2Parser.VARIABLE, 0)

        def LET(self):
            return self.getToken(milestone_2Parser.LET, 0)

        def CONST(self):
            return self.getToken(milestone_2Parser.CONST, 0)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_assignKeyw

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignKeyw" ):
                listener.enterAssignKeyw(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignKeyw" ):
                listener.exitAssignKeyw(self)




    def assignKeyw(self):

        localctx = milestone_2Parser.AssignKeywContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_assignKeyw)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            _la = self._input.LA(1)
            if not(((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & ((1 << (milestone_2Parser.CONST - 25)) | (1 << (milestone_2Parser.LET - 25)) | (1 << (milestone_2Parser.VARIABLE - 25)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssignDataTypesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.DIGIT)
            else:
                return self.getToken(milestone_2Parser.DIGIT, i)

        def INT8_LIT(self):
            return self.getToken(milestone_2Parser.INT8_LIT, 0)

        def INT16_LIT(self):
            return self.getToken(milestone_2Parser.INT16_LIT, 0)

        def INT32_LIT(self):
            return self.getToken(milestone_2Parser.INT32_LIT, 0)

        def INT64_LIT(self):
            return self.getToken(milestone_2Parser.INT64_LIT, 0)

        def UINT_LIT(self):
            return self.getToken(milestone_2Parser.UINT_LIT, 0)

        def UINT8_LIT(self):
            return self.getToken(milestone_2Parser.UINT8_LIT, 0)

        def UINT16_LIT(self):
            return self.getToken(milestone_2Parser.UINT16_LIT, 0)

        def UINT32_LIT(self):
            return self.getToken(milestone_2Parser.UINT32_LIT, 0)

        def UINT64_LIT(self):
            return self.getToken(milestone_2Parser.UINT64_LIT, 0)

        def FLOAT_LIT(self):
            return self.getToken(milestone_2Parser.FLOAT_LIT, 0)

        def FLOAT32_LIT(self):
            return self.getToken(milestone_2Parser.FLOAT32_LIT, 0)

        def FLOAT64_LIT(self):
            return self.getToken(milestone_2Parser.FLOAT64_LIT, 0)

        def STR_LIT(self):
            return self.getToken(milestone_2Parser.STR_LIT, 0)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_assignDataTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignDataTypes" ):
                listener.enterAssignDataTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignDataTypes" ):
                listener.exitAssignDataTypes(self)




    def assignDataTypes(self):

        localctx = milestone_2Parser.AssignDataTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_assignDataTypes)
        self._la = 0 # Token type
        try:
            self.state = 80
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [milestone_2Parser.DIGIT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 63 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 62
                    self.match(milestone_2Parser.DIGIT)
                    self.state = 65 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==milestone_2Parser.DIGIT):
                        break

                pass
            elif token in [milestone_2Parser.INT8_LIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 67
                self.match(milestone_2Parser.INT8_LIT)
                pass
            elif token in [milestone_2Parser.INT16_LIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 68
                self.match(milestone_2Parser.INT16_LIT)
                pass
            elif token in [milestone_2Parser.INT32_LIT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 69
                self.match(milestone_2Parser.INT32_LIT)
                pass
            elif token in [milestone_2Parser.INT64_LIT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 70
                self.match(milestone_2Parser.INT64_LIT)
                pass
            elif token in [milestone_2Parser.UINT_LIT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 71
                self.match(milestone_2Parser.UINT_LIT)
                pass
            elif token in [milestone_2Parser.UINT8_LIT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 72
                self.match(milestone_2Parser.UINT8_LIT)
                pass
            elif token in [milestone_2Parser.UINT16_LIT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 73
                self.match(milestone_2Parser.UINT16_LIT)
                pass
            elif token in [milestone_2Parser.UINT32_LIT]:
                self.enterOuterAlt(localctx, 9)
                self.state = 74
                self.match(milestone_2Parser.UINT32_LIT)
                pass
            elif token in [milestone_2Parser.UINT64_LIT]:
                self.enterOuterAlt(localctx, 10)
                self.state = 75
                self.match(milestone_2Parser.UINT64_LIT)
                pass
            elif token in [milestone_2Parser.FLOAT_LIT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 76
                self.match(milestone_2Parser.FLOAT_LIT)
                pass
            elif token in [milestone_2Parser.FLOAT32_LIT]:
                self.enterOuterAlt(localctx, 12)
                self.state = 77
                self.match(milestone_2Parser.FLOAT32_LIT)
                pass
            elif token in [milestone_2Parser.FLOAT64_LIT]:
                self.enterOuterAlt(localctx, 13)
                self.state = 78
                self.match(milestone_2Parser.FLOAT64_LIT)
                pass
            elif token in [milestone_2Parser.STR_LIT]:
                self.enterOuterAlt(localctx, 14)
                self.state = 79
                self.match(milestone_2Parser.STR_LIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclareStmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignKeyw(self):
            return self.getTypedRuleContext(milestone_2Parser.AssignKeywContext,0)


        def declareStmtBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(milestone_2Parser.DeclareStmtBodyContext)
            else:
                return self.getTypedRuleContext(milestone_2Parser.DeclareStmtBodyContext,i)


        def INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.INDENT)
            else:
                return self.getToken(milestone_2Parser.INDENT, i)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_declareStmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclareStmt" ):
                listener.enterDeclareStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclareStmt" ):
                listener.exitDeclareStmt(self)




    def declareStmt(self):

        localctx = milestone_2Parser.DeclareStmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_declareStmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.assignKeyw()
            self.state = 87 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 84
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==milestone_2Parser.INDENT:
                    self.state = 83
                    self.match(milestone_2Parser.INDENT)


                self.state = 86
                self.declareStmtBody()
                self.state = 89 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & ((1 << (milestone_2Parser.IDENTIFIER - 82)) | (1 << (milestone_2Parser.COMMENT - 82)) | (1 << (milestone_2Parser.INDENT - 82)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclareStmtBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.IDENTIFIER)
            else:
                return self.getToken(milestone_2Parser.IDENTIFIER, i)

        def COLON(self):
            return self.getToken(milestone_2Parser.COLON, 0)

        def declareDataTypes(self):
            return self.getTypedRuleContext(milestone_2Parser.DeclareDataTypesContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(milestone_2Parser.COMMA)
            else:
                return self.getToken(milestone_2Parser.COMMA, i)

        def COMMENT(self):
            return self.getToken(milestone_2Parser.COMMENT, 0)

        def getRuleIndex(self):
            return milestone_2Parser.RULE_declareStmtBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclareStmtBody" ):
                listener.enterDeclareStmtBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclareStmtBody" ):
                listener.exitDeclareStmtBody(self)




    def declareStmtBody(self):

        localctx = milestone_2Parser.DeclareStmtBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_declareStmtBody)
        self._la = 0 # Token type
        try:
            self.state = 105
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [milestone_2Parser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self.match(milestone_2Parser.IDENTIFIER)
                self.state = 96
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==milestone_2Parser.COMMA:
                    self.state = 92
                    self.match(milestone_2Parser.COMMA)
                    self.state = 93
                    self.match(milestone_2Parser.IDENTIFIER)
                    self.state = 98
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 99
                self.match(milestone_2Parser.COLON)
                self.state = 100
                self.declareDataTypes()
                self.state = 102
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
                if la_ == 1:
                    self.state = 101
                    self.match(milestone_2Parser.COMMENT)


                pass
            elif token in [milestone_2Parser.COMMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.match(milestone_2Parser.COMMENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclareDataTypesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return milestone_2Parser.RULE_declareDataTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclareDataTypes" ):
                listener.enterDeclareDataTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclareDataTypes" ):
                listener.exitDeclareDataTypes(self)




    def declareDataTypes(self):

        localctx = milestone_2Parser.DeclareDataTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_declareDataTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << milestone_2Parser.T__0) | (1 << milestone_2Parser.T__1) | (1 << milestone_2Parser.T__2) | (1 << milestone_2Parser.T__3) | (1 << milestone_2Parser.T__4) | (1 << milestone_2Parser.T__5) | (1 << milestone_2Parser.T__6) | (1 << milestone_2Parser.T__7) | (1 << milestone_2Parser.T__8) | (1 << milestone_2Parser.T__9) | (1 << milestone_2Parser.T__10) | (1 << milestone_2Parser.T__11) | (1 << milestone_2Parser.T__12) | (1 << milestone_2Parser.T__13) | (1 << milestone_2Parser.T__14))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignStmt(self):
            return self.getTypedRuleContext(milestone_2Parser.AssignStmtContext,0)


        def importStmt(self):
            return self.getTypedRuleContext(milestone_2Parser.ImportStmtContext,0)


        def declareStmt(self):
            return self.getTypedRuleContext(milestone_2Parser.DeclareStmtContext,0)


        def getRuleIndex(self):
            return milestone_2Parser.RULE_stmts

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmts" ):
                listener.enterStmts(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmts" ):
                listener.exitStmts(self)




    def stmts(self):

        localctx = milestone_2Parser.StmtsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_stmts)
        try:
            self.state = 112
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.assignStmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.importStmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.declareStmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmts(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(milestone_2Parser.StmtsContext)
            else:
                return self.getTypedRuleContext(milestone_2Parser.StmtsContext,i)


        def getRuleIndex(self):
            return milestone_2Parser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = milestone_2Parser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & ((1 << (milestone_2Parser.CONST - 25)) | (1 << (milestone_2Parser.FROM - 25)) | (1 << (milestone_2Parser.IMPORT - 25)) | (1 << (milestone_2Parser.LET - 25)) | (1 << (milestone_2Parser.VARIABLE - 25)))) != 0):
                self.state = 114
                self.stmts()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





